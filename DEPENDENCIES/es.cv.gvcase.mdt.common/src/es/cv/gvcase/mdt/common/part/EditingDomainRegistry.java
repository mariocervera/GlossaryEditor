///*******************************************************************************
// * Copyright (c) 2008, 2009 Conselleria de Infraestructuras y Transporte, Generalitat 
// * de la Comunitat Valenciana . All rights reserved. This program
// * and the accompanying materials are made available under the terms of the
// * Eclipse Public License v1.0 which accompanies this distribution, and is
// * available at http://www.eclipse.org/legal/epl-v10.html
// * 
// * Contributors: Francisco Javier Cano Muñoz (Prodevelop) – Initial implementation.
// * 				 Gabriel Merin Cubero (Prodevelop) – Expanded functionality
// *
// ******************************************************************************/
//package es.cv.gvcase.mdt.common.part;
//
//import java.util.ArrayList;
//import java.util.HashMap;
//import java.util.Iterator;
//import java.util.List;
//import java.util.Map.Entry;
//
//import org.eclipse.emf.common.util.URI;
//import org.eclipse.emf.transaction.TransactionalEditingDomain;
//import org.eclipse.ui.IEditorInput;
//import org.eclipse.ui.IEditorPart;
//import org.eclipse.ui.IEditorReference;
//import org.eclipse.ui.IPartListener2;
//import org.eclipse.ui.IViewPart;
//import org.eclipse.ui.IViewReference;
//import org.eclipse.ui.IWorkbenchPart;
//import org.eclipse.ui.IWorkbenchPartReference;
//import org.eclipse.ui.PlatformUI;
//
//import es.cv.gvcase.emf.common.part.IEditingDomainRegistrable;
//import es.cv.gvcase.emf.common.part.EditingDomainRegistry.IDomainSearchStrategy;
//import es.cv.gvcase.emf.common.util.PathsUtil;
//import es.cv.gvcase.mdt.common.commands.OpenAsDiagramCommand;
//
///**
// * A registry that MOSKitt editors use to get and share
// * {@link TransactionalEditingDomain}s. <br>
// * MOSKitt editors always ask this registry to get a
// * {@link TransactionalEditingDomain}. <br>
// * Sharing of editing domains is based on editing domain identifier provided by
// * the editor and the editor input to be edited. <br>
// * MOSKitt editors inside a {@link MOSKittMultiPageEditor} always share the same
// * editing domain, regardless of editing domain identifiers and editor inputs
// * being edited. <br>
// * This class is <b>deprecated</b>. All operations in this registry are
// * delegated on the {@link es.cv.gvcase.emf.common.part.EditingDomainRegistry}.
// * 
// * @see es.cv.gvcase.emf.common.part.EditingDomainRegistry
// * @author <a href="mailto:fjcano@prodevelop.es">Francisco Javier Cano Muñoz</a>
// * @author <a href="mailto:gmerin@prodevelop.es">Gabriel Merin Cubero</a>
// * @deprecated
// */
//public class EditingDomainRegistry extends
//		HashMap<String, TransactionalEditingDomain> implements IPartListener2 {
//
//	/**
//	 * Serial version unique identifier automatically generated by Eclipse.
//	 */
//	private static final long serialVersionUID = -1031171275310957702L;
//
//	// // Singleton
//
//	/**
//	 * The singleton instance.
//	 * */
//	private static EditingDomainRegistry INSTANCE = null;
//
//	/**
//	 * Instantiates a new {@link EditingDomainRegistry}. Private for singleton.
//	 */
//	private EditingDomainRegistry() {
//		return;
//	}
//
//	/**
//	 * Gets the single instance of {@link EditingDomainRegistry}.
//	 * 
//	 * @return single instance of {@link EditingDomainRegistry}
//	 */
//	public static EditingDomainRegistry getInstance() {
//		if (INSTANCE == null) {
//			INSTANCE = new EditingDomainRegistry();
//		}
//		return INSTANCE;
//	}
//
//	/**
//	 * Flag to know whether the registry has been added as a listener to the
//	 * workbench. Will be true if the registry is already listening to
//	 * {@link IWorkbenchPart}s life cycles.
//	 **/
//	private boolean listening = false;
//
//	/**
//	 * Flag to know if a change of {@link CachedResourcesDiagramEditor} is
//	 * taking place because of an {@link OpenAsDiagramCommand}.
//	 * **/
//	private boolean changingCachedEditors = false;
//
//	/**
//	 * Start listening to {@link IWorkbenchPart}s life cycles.
//	 */
//	private void startListening() {
//		if (listening) {
//			return;
//		}
//		try {
//			// register the EditingDomainRegistry as the listener.
//			PlatformUI.getWorkbench().getActiveWorkbenchWindow()
//					.getActivePage().addPartListener(getInstance());
//			listening = true;
//		} catch (NullPointerException e) {
//			// workbench not yet ready.
//			// register will listen to IWOrkbenchParts life cycle later.
//			;
//		}
//	}
//
//	// //
//
//	private static final String AMarker = ">-<";
//
//	/**
//	 * Calculate key from an editing domain identifier and a uri.
//	 * 
//	 * @param editorID
//	 *            the editor id
//	 * @param uri
//	 *            the uri
//	 * 
//	 * @return the string
//	 */
//	protected String calculateKey(String editingDomainID, String uri) {
//		uri = PathsUtil.fromAbsoluteFileSystemToAbsoluteWorkspace(uri);
//		String key = ((uri != null) ? (editingDomainID + AMarker + uri)
//				: editingDomainID);
//		return key;
//	}
//
//	/**
//	 * Default {@link HashMap#get(Object)} overridden to use the new
//	 * implementation.
//	 * 
//	 * @see java.util.HashMap#get(java.lang.Object)
//	 */
//	@Override
//	public TransactionalEditingDomain get(Object okey) {
//		// delegate to es.cv.gvcase.emf.common.part.EditingDomainRegistry
//		return es.cv.gvcase.emf.common.part.EditingDomainRegistry.getInstance()
//				.get(okey);
//	}
//
//	/**
//	 * Gets (creates if necessary) a {@link TransactionalEditingDomain} using
//	 * the given editing domain identifier and the given editor input to build
//	 * the key.
//	 * 
//	 * @return the transactional editing domain
//	 */
//	public TransactionalEditingDomain get(String editingDomainID,
//			IEditorInput editorInput) {
//		// delegate to es.cv.gvcase.emf.common.part.EditingDomainRegistry
//		return es.cv.gvcase.emf.common.part.EditingDomainRegistry.getInstance()
//				.getSharedEditingDomain();
//	}
//
//	/**
//	 * Gets (creates if necessary) a {@link TransactionalEditingDomain} using
//	 * the given editing domain identifier and the given uri to build the key.
//	 * 
//	 * @param editingDomainID
//	 *            the editor id
//	 * @param uri
//	 *            the uri
//	 * 
//	 * @return the transactional editing domain
//	 */
//	public TransactionalEditingDomain get(String editingDomainID, String uri) {
//		// delegate to es.cv.gvcase.emf.common.part.EditingDomainRegistry
//		return get(editingDomainID, uri, null);
//	}
//
//	/**
//	 * Gets (creates if necessary) a {@link TransactionalEditingDomain} for the
//	 * given resource via its {@link URI}. If a strategy is given, that strategy
//	 * will be used, otherwise the default strategy will be used.
//	 * 
//	 * @param editingDomainID
//	 * @param editorInput
//	 * @param strategy
//	 * @return
//	 */
//	public TransactionalEditingDomain get(String editingDomainID,
//			IEditorInput editorInput, IDomainSearchStrategy strategy) {
//		// delegate to es.cv.gvcase.emf.common.part.EditingDomainRegistry
//		return es.cv.gvcase.emf.common.part.EditingDomainRegistry.getInstance()
//				.get(editingDomainID, editorInput, strategy);
//	}
//
//	/**
//	 * Gets (creates if necessary) a {@link TransactionalEditingDomain} using
//	 * the given resource via its {@link URI}. If a strategy is given, that
//	 * strategy will be used, otherwise the default strategy will be used.
//	 * 
//	 * @param editingDomainID
//	 * @param uri
//	 * @param strategy
//	 * @return
//	 */
//	public TransactionalEditingDomain get(String editingDomainID, String uri,
//			IDomainSearchStrategy strategy) {
//		// delegate to es.cv.gvcase.emf.common.part.EditingDomainRegistry
//		return es.cv.gvcase.emf.common.part.EditingDomainRegistry.getInstance()
//				.get(editingDomainID, uri, strategy);
//	}
//
//	/**
//	 * Check if a {@link TransactionalEditingDomain} fort he given editing
//	 * domain identifier and the given {@link IEditorInput} is already
//	 * registered in this registry.
//	 * 
//	 * @param editingDomainID
//	 * @param editorInput
//	 * @return
//	 */
//	public boolean contains(String editingDomainID, IEditorInput editorInput) {
//		// delegate to es.cv.gvcase.emf.common.part.EditingDomainRegistry
//		return es.cv.gvcase.emf.common.part.EditingDomainRegistry.getInstance()
//				.contains(editingDomainID, editorInput);
//	}
//
//	/**
//	 * Check if a {@link TransactionalEditingDomain} for the given editing
//	 * domain identifier and the given uri is already registered in this
//	 * registry.
//	 * 
//	 * @param editingDomainID
//	 * @param uri
//	 * @return
//	 */
//	public boolean contains(String editingDomainID, String uri) {
//		// delegate to es.cv.gvcase.emf.common.part.EditingDomainRegistry
//		return es.cv.gvcase.emf.common.part.EditingDomainRegistry.getInstance()
//				.contains(editingDomainID, uri);
//	}
//
//	/**
//	 * Add a {@link TransactionalEditingDomain} to this registry using the given
//	 * editing domain identifier and the given editor input to generate the key.
//	 * 
//	 * @param editingDomainID
//	 * @param editorInput
//	 * @param domain
//	 */
//	public void put(String editingDomainID, IEditorInput editorInput,
//			TransactionalEditingDomain domain) {
//		// delegate to es.cv.gvcase.emf.common.part.EditingDomainRegistry
//		es.cv.gvcase.emf.common.part.EditingDomainRegistry.getInstance().put(
//				editingDomainID, editorInput, domain);
//	}
//
//	/**
//	 * Add a {@link TransactionalEditingDomain} to this registry using the given
//	 * editing domain identifier and the given uri to generate the key.
//	 * 
//	 * @param editingDomainID
//	 * @param uri
//	 * @param domain
//	 */
//	public void put(String editingDomainID, String uri,
//			TransactionalEditingDomain domain) {
//		// delegate to es.cv.gvcase.emf.common.part.EditingDomainRegistry
//		es.cv.gvcase.emf.common.part.EditingDomainRegistry.getInstance().put(
//				editingDomainID, uri, domain);
//	}
//
//	/**
//	 * Look up in the registry for {@link TransactionalEditingDomain}s that are
//	 * no longer in use and remove them from the registry.
//	 * 
//	 * @param partReference
//	 *            the part reference
//	 */
//	private void cleanRegistry(IWorkbenchPartReference partReference) {
//		if (isChangingCachedEditors()) {
//			// when we are changing from one editor to another because of an
//			// OpenAsDiagramCommand there is no need to perform a clean.
//			return;
//		}
//
//		List<IEditingDomainRegistrable> views = new ArrayList<IEditingDomainRegistrable>();
//
//		// Search for the editors currently open in the workbench page.
//		for (IEditorReference editorRef : partReference.getPage()
//				.getEditorReferences()) {
//			IEditorPart editor = editorRef.getEditor(false);
//			if (editor instanceof IEditingDomainRegistrable) {
//				views.add((IEditingDomainRegistrable) editor);
//			}
//		}
//
//		// Search for other views that are not editors but that may have
//		// registered a TRansactionalEditingDomain.
//		for (IViewReference viewRef : partReference.getPage()
//				.getViewReferences()) {
//			IViewPart view = viewRef.getView(false);
//			if (view instanceof IEditingDomainRegistrable) {
//				views.add((IEditingDomainRegistrable) view);
//			}
//		}
//		// perform clean only on possibly affected views.
//		cleanRegistry(views);
//	}
//
//	/**
//	 * Look up in the registry for {@link TransactionalEditingDomain}s that are
//	 * no longer in use and remove them from the registry.
//	 * 
//	 * @param editors
//	 *            the editors
//	 */
//	private void cleanRegistry(List<IEditingDomainRegistrable> views) {
//		/**
//		 * Since this registry is deprecated and the EditingDomainRegistry from
//		 * the 'es.cv.gvcase.emf.common' plugin is the one actually used, this
//		 * cleanup method is no longer used.
//		 */
//		// get keys list from open editors
//		List<String> keys = new ArrayList<String>();
//		for (IEditingDomainRegistrable view : views) {
//			String uri = view.getEditingDomainResourceURI();
//			// If there is no URI, then there is no resource being edited
//			if (uri == null)
//				continue;
//			String id = view.getEditingDomainID();
//			String key = calculateKey(id, uri);
//			keys.add(key);
//		}
//		// find keys that are no longer in use
//		List<String> keysToRemove = new ArrayList<String>();
//		for (String key : keySet()) {
//			if (keys.contains(key) == false) {
//				keysToRemove.add(key);
//			}
//		}
//		// remove no longer used editing domains and keys
//		List<TransactionalEditingDomain> disposedDomains = new ArrayList<TransactionalEditingDomain>();
//		// search for all editing domains that are no longer being used
//		for (Entry<String, TransactionalEditingDomain> entry : entrySet()) {
//			if (keysToRemove.contains(entry.getKey())) {
//				TransactionalEditingDomain domain = entry.getValue();
//				if (!disposedDomains.contains(domain)) {
//					disposedDomains.add(domain);
//				}
//			}
//		}
//		// remove all keys that are no longer used
//		for (String key : keysToRemove) {
//			remove(key);
//		}
//		// dispose all editing domains that are no longer in use
//		TransactionalEditingDomain domain = null;
//		for (Iterator<TransactionalEditingDomain> domains = disposedDomains.iterator(); domains.hasNext(); ) {
//			domain = domains.next();
//			if (!values().contains(domain)) {
//				domain.dispose();
//			}
//		}
//	}
//
//	/*
//	 * (non-Javadoc)
//	 * 
//	 * @seeorg.eclipse.ui.IPartListener2#partActivated(org.eclipse.ui.
//	 * IWorkbenchPartReference)
//	 */
//	public void partActivated(IWorkbenchPartReference partRef) {
//		// nothing to do
//	}
//
//	/*
//	 * (non-Javadoc)
//	 * 
//	 * @seeorg.eclipse.ui.IPartListener2#partBroughtToTop(org.eclipse.ui.
//	 * IWorkbenchPartReference)
//	 */
//	public void partBroughtToTop(IWorkbenchPartReference partRef) {
//		// nothing to do
//	}
//
//	/*
//	 * (non-Javadoc)
//	 * 
//	 * @seeorg.eclipse.ui.IPartListener2#partClosed(org.eclipse.ui.
//	 * IWorkbenchPartReference)
//	 */
//	public void partClosed(IWorkbenchPartReference partRef) {
//		cleanRegistry(partRef);
//	}
//
//	/*
//	 * (non-Javadoc)
//	 * 
//	 * @seeorg.eclipse.ui.IPartListener2#partDeactivated(org.eclipse.ui.
//	 * IWorkbenchPartReference)
//	 */
//	public void partDeactivated(IWorkbenchPartReference partRef) {
//		// nothing to do
//	}
//
//	/*
//	 * (non-Javadoc)
//	 * 
//	 * @seeorg.eclipse.ui.IPartListener2#partHidden(org.eclipse.ui.
//	 * IWorkbenchPartReference)
//	 */
//	public void partHidden(IWorkbenchPartReference partRef) {
//		// nothing to do
//	}
//
//	/*
//	 * (non-Javadoc)
//	 * 
//	 * @seeorg.eclipse.ui.IPartListener2#partInputChanged(org.eclipse.ui.
//	 * IWorkbenchPartReference)
//	 */
//	public void partInputChanged(IWorkbenchPartReference partRef) {
//		cleanRegistry(partRef);
//	}
//
//	/*
//	 * (non-Javadoc)
//	 * 
//	 * @seeorg.eclipse.ui.IPartListener2#partOpened(org.eclipse.ui.
//	 * IWorkbenchPartReference)
//	 */
//	public void partOpened(IWorkbenchPartReference partRef) {
//		// nothing to do
//	}
//
//	/*
//	 * (non-Javadoc)
//	 * 
//	 * @seeorg.eclipse.ui.IPartListener2#partVisible(org.eclipse.ui.
//	 * IWorkbenchPartReference)
//	 */
//	public void partVisible(IWorkbenchPartReference partRef) {
//		// nothing to do
//	}
//
//	/**
//	 * Checks if a change of editors because of an {@link OpenAsDiagramCommand}
//	 * is taking place.
//	 * 
//	 * @return true, if is changing cached editors
//	 */
//	public boolean isChangingCachedEditors() {
//		return changingCachedEditors;
//	}
//
//	/**
//	 * Sets the changing cached editors.
//	 * 
//	 * @param changingCachedEditors
//	 *            the new changing cached editors
//	 */
//	public void setChangingCachedEditors(boolean changingCachedEditors) {
//		this.changingCachedEditors = changingCachedEditors;
//	}
// }
