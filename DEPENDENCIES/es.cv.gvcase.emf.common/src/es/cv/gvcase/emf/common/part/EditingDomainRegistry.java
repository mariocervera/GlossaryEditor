/*******************************************************************************
 * Copyright (c) 2008, 2009 Conselleria de Infraestructuras y Transporte, Generalitat 
 * de la Comunitat Valenciana . All rights reserved. This program
 * and the accompanying materials are made available under the terms of the
 * Eclipse Public License v1.0 which accompanies this distribution, and is
 * available at http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors: Francisco Javier Cano Muñoz (Prodevelop) – Initial implementation.
 * 				 Gabriel Merin Cubero (Prodevelop) – Expanded functionality
 * 				 Jose Manuel García Valladolid (Indra SL) - Refactoring and generic TransactionalEditingDomain support
 *
 ******************************************************************************/
package es.cv.gvcase.emf.common.part;

import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.eclipse.emf.common.notify.Adapter;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.Notifier;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.emf.transaction.NotificationFilter;
import org.eclipse.emf.transaction.ResourceSetListener;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.TransactionalEditingDomain.Factory;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IEditorReference;
import org.eclipse.ui.IPartListener2;
import org.eclipse.ui.IViewPart;
import org.eclipse.ui.IViewReference;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.IWorkbenchPartReference;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PlatformUI;

import es.cv.gvcase.emf.common.util.PathsUtil;

/**
 * A registry that MOSKitt editors use to get and share
 * {@link TransactionalEditingDomain}s. <br>
 * MOSKitt editors always ask this registry to get a
 * {@link TransactionalEditingDomain}. <br>
 * Sharing of editing domains is based on editing domain identifier provided by
 * the editor and the editor input to be edited. <br>
 * MOSKitt editors inside a {@link MOSKittMultiPageEditor} always share the same
 * editing domain, regardless of editing domain identifiers and editor inputs
 * being edited.
 * 
 * @author <a href="mailto:fjcano@prodevelop.es>Francisco Javier Cano Muñoz</a>
 * @author <a href="mailto:gmerin@prodevelop.es>Gabriel Merin Cubero</a>
 */
public class EditingDomainRegistry extends
		HashMap<String, TransactionalEditingDomain> implements IPartListener2 {

	// //
	// Strategy interface for searching editing domains
	// //
	/**
	 * Interface to search for {@link TransactionalEditingDomain}s that can edit
	 * a {@link Resource} (referenced by its uri) in a {@link Map} with
	 * TransactionalEditingDomains as values. <br>
	 * This interface is used in the get method of this registry to allow
	 * clients to implements their own search strategies. A simple default one
	 * is used if none is provided.
	 * 
	 */
	public interface IDomainSearchStrategy {
		TransactionalEditingDomain get(String id, String uri,
				Map<String, TransactionalEditingDomain> key2Domain);
	}

	/**
	 * Default strategy to use in the get method of this registry. It searches
	 * in all the resources of all the editing domains for one that matches the
	 * given uri.
	 */
	private IDomainSearchStrategy simpleDomainSearchStrategy = null;

	/**
	 * This method exposes the simple {@link IDomainSearchStrategy} to clients.
	 * 
	 * @return
	 */
	public IDomainSearchStrategy getSimpleDomainSearchStrategy() {
		if (simpleDomainSearchStrategy == null) {
			simpleDomainSearchStrategy = new SimpleDomainSearchStrategy();
		}
		return simpleDomainSearchStrategy;
	}

	/**
	 * Serial version unique identifier automatically generated by Eclipse.
	 */
	private static final long serialVersionUID = -1031171275310957702L;

	// // Singleton

	/**
	 * The singleton instance.
	 * */
	private static EditingDomainRegistry INSTANCE = null;

	/**
	 * Instantiates a new {@link EditingDomainRegistry}. Private for singleton.
	 */
	private EditingDomainRegistry() {
		return;
	}

	/**
	 * Gets the single instance of {@link EditingDomainRegistry}.
	 * 
	 * @return single instance of {@link EditingDomainRegistry}
	 */
	public static EditingDomainRegistry getInstance() {
		if (INSTANCE == null) {
			INSTANCE = new EditingDomainRegistry();
		}
		return INSTANCE;
	}

	/**
	 * Flag to know whether the registry has been added as a listener to the
	 * workbench. Will be true if the registry is already listening to
	 * {@link IWorkbenchPart}s life cycles.
	 **/
	private boolean listening = false;

	/**
	 * Flag to know if a change of {@link CachedResourcesDiagramEditor} is
	 * taking place because of an {@link OpenAsDiagramCommand}.
	 * **/
	private boolean changingCachedEditors = false;

	/**
	 * Start listening to {@link IWorkbenchPart}s life cycles.
	 */
	private void startListening() {
		if (listening) {
			return;
		}
		try {
			// register the EditingDomainRegistry as the listener.
			IWorkbenchWindow ww = PlatformUI.getWorkbench()
					.getActiveWorkbenchWindow();
			if (ww != null && ww.getActivePage() != null) {
				ww.getActivePage().addPartListener(getInstance());
				listening = true;
			}
		} catch (NullPointerException e) {
			// workbench not yet ready.
			// register will listen to IWorkbenchParts life cycle later.
		}
	}

	// //
	/**
	 * Arbitrary marker to build keys.
	 */
	public static final String AMarker = ">-<";

	/**
	 * Calculate key from an editing domain identifier and a uri.
	 * 
	 * @param editorID
	 *            the editor id
	 * @param uri
	 *            the uri
	 * 
	 * @return the string
	 */
	public String calculateKey(String editingDomainID, String uri) {
		uri = PathsUtil.fromAbsoluteFileSystemToAbsoluteWorkspace(uri, false);
		String key = ((uri != null) ? (editingDomainID + AMarker + uri)
				: editingDomainID);
		return key;
	}

	/**
	 * Retrieves the {@link Factory} that must create the {@link EditingDomain}.
	 * Different EditingDomainFactories can be added via Extension Points.
	 * 
	 * @return {@link Factory}
	 */
	protected Factory getEditingDomainFactory() {
		Factory factory = EditingDomainFactoryRegistry.getInstance()
				.getFactory();
		return factory != null ? factory
				: TransactionalEditingDomain.Factory.INSTANCE;
	}

	/**
	 * Default {@link HashMap#get(Object)} overridden to use the new
	 * implementation.
	 * 
	 * @see java.util.HashMap#get(java.lang.Object)
	 */
	@Override
	public TransactionalEditingDomain get(Object okey) {
		return super.get(okey);
	}

	/**
	 * Gets (creates if necessary) a {@link TransactionalEditingDomain} using
	 * the given editing domain identifier and the given editor input to build
	 * the key.
	 * 
	 * @return the transactional editing domain
	 */
	public TransactionalEditingDomain get(String editingDomainID,
			IEditorInput editorInput) {
		String uri = PathsUtil.fromEditorInputToURIString(editorInput);
		// delegate to default method
		return get(editingDomainID, uri, null);
	}

	/**
	 * Gets (creates if necessary) a {@link TransactionalEditingDomain} using
	 * the given editing domain identifier and the given editor input to build
	 * the key.
	 * 
	 * @return the transactional editing domain
	 */
	public TransactionalEditingDomain get(String editingDomainID,
			IEditorInput editorInput, IDomainSearchStrategy strategy) {
		String uri = PathsUtil.fromEditorInputToURIString(editorInput);
		// delegate to default method
		return get(editingDomainID, uri, strategy);
	}

	/**
	 * Gets (creates if necessary) a {@link TransactionalEditingDomain} using
	 * the given editing domain identifier and the given uri to build the key.
	 * 
	 * @param editingDomainID
	 *            the editor id
	 * @param uri
	 *            the uri
	 * 
	 * @return the transactional editing domain
	 */
	public TransactionalEditingDomain get(String editingDomainID, String uri) {
		// delegate to default method
		return get(editingDomainID, uri, null);
	}

	/**
	 * Gets (creates if necessary) a {@link TransactionalEditingDomain} using
	 * the given editing domain identifier and the given uri to build the key.
	 * 
	 * @param editingDomainID
	 *            the editor id
	 * @param uri
	 *            the uri
	 * 
	 * @return the transactional editing domain
	 */
	public TransactionalEditingDomain get(String editingDomainID, String uri,
			IDomainSearchStrategy strategy) {
		// we need to listen to IWorkbenchParts life cycles.
		startListening();
		// first, look for an existing and suitable editing domain in the
		// registry that we can use
		TransactionalEditingDomain domain = null;
		if (contains(editingDomainID, uri)) {
			return super.get(calculateKey(editingDomainID, uri));
		}
		// If there is no TransactionalEditingDomain registered, search for one.
		if (strategy != null) {
			// if a search Strategy is given, use that one.
			domain = strategy.get(editingDomainID, uri, this);
		} else {
			// if no search strategy is given, use the default one
			domain = getSimpleDomainSearchStrategy().get(editingDomainID, uri,
					this);
		}
		if (domain != null && domain.getID() != "") {
			// if a domain was found
			return domain;
		}
		// no domain found, return a new editing domain
		return createNewEditingDomain(editingDomainID, uri);
	}

	/**
	 * Return whether a {@link TransactionalEditingDomain} for the given id and
	 * input is registered
	 * 
	 * @param editingDomainID
	 *            the identifier of the editing domain
	 * @param editorInput
	 *            the editor input
	 * @return a {@link TransactionalEditingDomain} if any is registered, null
	 *         otherwise
	 */
	public TransactionalEditingDomain hasDomain(String editingDomainID,
			IEditorInput editorInput) {
		String uri = PathsUtil.fromEditorInputToURIString(editorInput);
		return hasDomain(editingDomainID, uri);
	}

	/**
	 * Return whether a {@link TransactionalEditingDomain} for the given id and
	 * uri is registered
	 * 
	 * @param editingDomainID
	 *            the identifier of the editing domain
	 * @param uri
	 *            the resource uri
	 * @return a {@link TransactionalEditingDomain} if any is registered, null
	 *         otherwise
	 */
	public TransactionalEditingDomain hasDomain(String editingDomainID,
			String uri) {
		return hasDomain(editingDomainID, uri, null);
	}

	/**
	 * Return whether a {@link TransactionalEditingDomain} for the given id and
	 * uri is registered using the given strategy
	 * 
	 * @param editingDomainID
	 *            the identifier of the editing domain
	 * @param uri
	 *            the resource uri
	 * @param strategy
	 *            the strategy to use in the search of the editing domain
	 * @return a {@link TransactionalEditingDomain} if any is registeres, null
	 *         otherwise
	 */
	public TransactionalEditingDomain hasDomain(String editingDomainID,
			String uri, IDomainSearchStrategy strategy) {
		// we need to listen to IWorkbenchParts life cycles.
		startListening();
		// first, look for an existing and suitable editing domain in the
		// register that we can use
		TransactionalEditingDomain domain = null;
		if (contains(editingDomainID, uri)) {
			return super.get(calculateKey(editingDomainID, uri));
		}
		// If there is no TransactionalEditingDomain registered, search for one.
		if (strategy != null) {
			// if a search Strategy is given, use that one.
			domain = strategy.get(editingDomainID, uri, this);
		} else {
			// if no search strategy is given, use the default one
			domain = getSimpleDomainSearchStrategy().get(editingDomainID, uri,
					this);
		}
		if (domain != null) {
			// if a domain was found
			return domain;
		}
		// no editing domain found
		return null;
	}

	/**
	 * Creates a new {@link TransactionalEditingDomain} using the
	 * {@link EditingDomainFactory} with the highest priority.
	 * 
	 * @param editingDomainID
	 * @param uri
	 * @return
	 */
	protected TransactionalEditingDomain createNewEditingDomain(
			String editingDomainID, String uri) {
		// calculate the key with which the new editing domain will be
		// registered
		String key = calculateKey(editingDomainID, uri);
		// create a new editing domain with the highest priority factory
		TransactionalEditingDomain newDomain = getEditingDomainFactory()
				.createEditingDomain();
		// set this domain ID
		newDomain.setID(editingDomainID);
		// add a NotificationFilter to the editing domain
		final NotificationFilter diagramResourceModifiedFilter = NotificationFilter
				.createNotifierFilter(newDomain.getResourceSet()).and(
						NotificationFilter
								.createEventTypeFilter(Notification.ADD)).and(
						NotificationFilter.createFeatureFilter(
								ResourceSet.class,
								ResourceSet.RESOURCE_SET__RESOURCES));
		// add an adapter to the editing domain
		newDomain.getResourceSet().eAdapters().add(new Adapter() {

			private Notifier myTarget;

			public Notifier getTarget() {
				return myTarget;
			}

			public boolean isAdapterForType(Object type) {
				return false;
			}

			public void notifyChanged(Notification notification) {
				if (diagramResourceModifiedFilter.matches(notification)) {
					Object value = notification.getNewValue();
					if (value instanceof Resource) {
						((Resource) value).setTrackingModification(true);
					}
				}
			}

			public void setTarget(Notifier newTarget) {
				myTarget = newTarget;
			}

		});
		// add the new editing domain to this register.
		put(key, newDomain);
		// newDomain.addResourceSetListener(new
		// ResourceAddedListener(newDomain));
		// return the new editing domain
		// add the resource set listeners available in the listeners list
		if (resourceSetListeners != null) {
			for (ResourceSetListener listener : resourceSetListeners) {
				newDomain.addResourceSetListener(listener);
			}
		}
		return newDomain;
	}

	/**
	 * Check if a {@link TransactionalEditingDomain} fort he given editing
	 * domain identifier and the given {@link IEditorInput} is already
	 * registered in this registry.
	 * 
	 * @param editingDomainID
	 * @param editorInput
	 * @return
	 */
	public boolean contains(String editingDomainID, IEditorInput editorInput) {
		String uri = PathsUtil.fromEditorInputToURIString(editorInput);
		return contains(editingDomainID, uri);
	}

	/**
	 * Check if a {@link TransactionalEditingDomain} for the given editing
	 * domain identifier and the given uri is already registered in this
	 * registry.
	 * 
	 * @param editingDomainID
	 * @param uri
	 * @return
	 */
	public boolean contains(String editingDomainID, String uri) {
		String key = calculateKey(editingDomainID, uri);
		return containsKey(key);
	}

	/**
	 * Add a {@link TransactionalEditingDomain} to this registry using the given
	 * editing domain identifier and the given editor input to generate the key.
	 * 
	 * @param editingDomainID
	 * @param editorInput
	 * @param domain
	 */
	public void put(String editingDomainID, IEditorInput editorInput,
			TransactionalEditingDomain domain) {
		String uri = PathsUtil.fromEditorInputToURIString(editorInput);
		put(editingDomainID, uri, domain);
	}

	/**
	 * Add a {@link TransactionalEditingDomain} to this registry using the given
	 * editing domain identifier and the given uri to generate the key.
	 * 
	 * @param editingDomainID
	 * @param uri
	 * @param domain
	 */
	public void put(String editingDomainID, String uri,
			TransactionalEditingDomain domain) {
		String key = calculateKey(editingDomainID, uri);
		put(key, domain);
	}

	/**
	 * Look up in the registry for {@link TransactionalEditingDomain}s that are
	 * no longer in use and remove them from the registry.
	 * 
	 * @param partReference
	 *            the part reference
	 */
	public void cleanRegistry(IWorkbenchPartReference partReference) {
		cleanRegistry(partReference.getPage());
	}

	/**
	 * Look up in the registry for {@link TransactionalEditingDomain}s that are
	 * no longer in use and remove them from the registry.
	 * 
	 * @param page
	 *            the workbench page
	 */
	public void cleanRegistry(IWorkbenchPage page) {
		if (isChangingCachedEditors()) {
			// when we are changing from one editor to another because of an
			// OpenAsDiagramCommand there is no need to perform a clean.
			return;
		}

		List<IEditingDomainRegistrable> views = new ArrayList<IEditingDomainRegistrable>();

		// Search for the editors currently open in the workbench page.
		for (IEditorReference editorRef : page.getEditorReferences()) {
			IEditorPart editor = editorRef.getEditor(false);
			if (editor instanceof IEditingDomainRegistrable) {
				views.add((IEditingDomainRegistrable) editor);
			}
		}

		// Search for other views that are not editors but that may have
		// registered a TRansactionalEditingDomain.
		for (IViewReference viewRef : page.getViewReferences()) {
			IViewPart view = viewRef.getView(false);
			if (view instanceof IEditingDomainRegistrable) {
				views.add((IEditingDomainRegistrable) view);
			}
		}
		// perform clean only on possibly affected views.
		cleanRegistry(views);
	}

	/**
	 * Look up in the registry for {@link TransactionalEditingDomain}s that are
	 * no longer in use and remove them from the registry.
	 * 
	 * @param editors
	 *            the editors
	 */
	private void cleanRegistry(List<IEditingDomainRegistrable> views) {
		// get keys list from open editors
		List<String> keys = new ArrayList<String>();
		for (IEditingDomainRegistrable view : views) {
			String uri = view.getEditingDomainResourceURI();
			// If there is no URI, then there is no resource being edited
			if (uri == null)
				continue;
			String id = view.getEditingDomainID();
			String key = calculateKey(id, uri);
			keys.add(key);
		}
		// find keys that are no longer in use
		List<String> keysToRemove = new ArrayList<String>();
		for (String key : keySet()) {
			if (keys.contains(key) == false) {
				keysToRemove.add(key);
			}
		}
		// remove no longer used editing domains and keys
		List<TransactionalEditingDomain> disposedDomains = new ArrayList<TransactionalEditingDomain>();
		// search for all editing domains that are no longer being used
		for (Entry<String, TransactionalEditingDomain> entry : entrySet()) {
			if (keysToRemove.contains(entry.getKey())) {
				TransactionalEditingDomain domain = entry.getValue();
				if (!disposedDomains.contains(domain)) {
					disposedDomains.add(domain);
				}
			}
		}
		// remove all keys that are no longer used
		for (String key : keysToRemove) {
			remove(key);
		}
		// dispose all editing domains that are no longer in use
		TransactionalEditingDomain domain = null;
		for (Iterator<TransactionalEditingDomain> domains = disposedDomains
				.iterator(); domains.hasNext();) {
			domain = domains.next();
			if (!values().contains(domain)) {
				try {
					domain.dispose();
				} catch (ConcurrentModificationException ex) {
					// fjcano :: this try-catch is to prevent a bug of GMF where
					// a Map is being modified while it is being iterated from
					// affecting the cleanup of the editing domain registry.
					continue;
				}
			}
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.eclipse.ui.IPartListener2#partActivated(org.eclipse.ui.
	 * IWorkbenchPartReference)
	 */
	public void partActivated(IWorkbenchPartReference partRef) {
		// nothing to do
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.eclipse.ui.IPartListener2#partBroughtToTop(org.eclipse.ui.
	 * IWorkbenchPartReference)
	 */
	public void partBroughtToTop(IWorkbenchPartReference partRef) {
		// nothing to do
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.eclipse.ui.IPartListener2#partClosed(org.eclipse.ui.
	 * IWorkbenchPartReference)
	 */
	public void partClosed(IWorkbenchPartReference partRef) {
		cleanRegistry(partRef);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.eclipse.ui.IPartListener2#partDeactivated(org.eclipse.ui.
	 * IWorkbenchPartReference)
	 */
	public void partDeactivated(IWorkbenchPartReference partRef) {
		// nothing to do
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.eclipse.ui.IPartListener2#partHidden(org.eclipse.ui.
	 * IWorkbenchPartReference)
	 */
	public void partHidden(IWorkbenchPartReference partRef) {
		// nothing to do
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.eclipse.ui.IPartListener2#partInputChanged(org.eclipse.ui.
	 * IWorkbenchPartReference)
	 */
	public void partInputChanged(IWorkbenchPartReference partRef) {
		cleanRegistry(partRef);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.eclipse.ui.IPartListener2#partOpened(org.eclipse.ui.
	 * IWorkbenchPartReference)
	 */
	public void partOpened(IWorkbenchPartReference partRef) {
		// nothing to do
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.eclipse.ui.IPartListener2#partVisible(org.eclipse.ui.
	 * IWorkbenchPartReference)
	 */
	public void partVisible(IWorkbenchPartReference partRef) {
		// nothing to do
	}

	/**
	 * Checks if a change of editors because of an {@link OpenAsDiagramCommand}
	 * is taking place.
	 * 
	 * @return true, if is changing cached editors
	 */
	public boolean isChangingCachedEditors() {
		return changingCachedEditors;
	}

	/**
	 * Sets the changing cached editors.
	 * 
	 * @param changingCachedEditors
	 *            the new changing cached editors
	 */
	public void setChangingCachedEditors(boolean changingCachedEditors) {
		this.changingCachedEditors = changingCachedEditors;
	}

	// //
	// Listeners to be added to the editing domains of this registry, both upon
	// creation or to already created ones.
	// //

	// list of ResourceSetListeners elements to be added.
	protected List<ResourceSetListener> resourceSetListeners = null;

	/**
	 * Registers a {@link ResourceSetListener} to be added to all the created
	 * editing domains. <br>
	 * Adds that listener to all the already existing editing domains.
	 * 
	 * @param listener
	 *            The {@link ResourceSetListener} to be added.
	 * @return true if the listener was successfully added.
	 */
	public boolean addResourceSetListener(ResourceSetListener listener) {
		if (listener == null) {
			return false;
		} else {
			if (resourceSetListeners == null) {
				resourceSetListeners = new ArrayList<ResourceSetListener>();
			}
			if (resourceSetListeners.contains(listener)) {
				return false;
			} else {
				resourceSetListeners.add(listener);
				// add the listener to all already existing editing domains.
				for (TransactionalEditingDomain domain : values()) {
					addListenerToEditingDomain(domain, listener);
				}
				return true;
			}
		}
	}

	/**
	 * Removes an already registered {@link ResourceSetListener} from the
	 * editing domains and the register of listeners to add to new editing
	 * domains. <br>
	 * 
	 * @param listener
	 *            The listener to be removed.
	 * @return true is the listener was successfully removed.
	 */
	public boolean removeResourceSetListener(ResourceSetListener listener) {
		if (listener == null) {
			return false;
		} else {
			if (resourceSetListeners != null) {
				if (resourceSetListeners.contains(listener)) {
					resourceSetListeners.remove(listener);
					// remove from all the existing editing domains
					for (TransactionalEditingDomain domain : values()) {
						removeListenerFromDomain(domain, listener);
					}
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		}
	}

	protected boolean removeListenerFromDomain(
			TransactionalEditingDomain domain, ResourceSetListener listener) {
		if (domain != null && listener != null) {
			domain.removeResourceSetListener(listener);
			return true;
		} else {
			return false;
		}
	}

	protected boolean addListenerToEditingDomain(
			TransactionalEditingDomain domain, ResourceSetListener listener) {
		if (domain != null && listener != null) {
			domain.addResourceSetListener(listener);
			return true;
		} else {
			return false;
		}
	}

}
